var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Logger_info, _Logger_warn, _Logger_error, _Logger_write;
import * as dntShim from "./_dnt.shims.js";
import stdout from "./stdout.js";
import Writer from "./writer.js";
import eol from "./eol.js";
import { exists } from "./fs.js";
import Dater from "./date.js";
import { green, red, stripAnsiCode, yellow } from "./deps.js";
import Types from "./types.js";
const { inspect } = dntShim.Deno;
const noop = async () => { };
/**
 * Logger class
 */
class Logger {
    constructor() {
        Object.defineProperty(this, "stdout", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: stdout
        });
        Object.defineProperty(this, "encoder", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new TextEncoder()
        });
        Object.defineProperty(this, "writer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "rotate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "dir", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        _Logger_info.set(this, this.info);
        _Logger_warn.set(this, this.warn);
        _Logger_error.set(this, this.error);
        _Logger_write.set(this, this.write);
    }
    format(...args) {
        const msg = args.map((arg) => typeof arg === "string" ? arg : inspect(arg))
            .join(" ");
        // const msg = args.map(arg => inspect(arg, {
        //   showHidden: true,
        //   depth: 4,
        //   colors: true,
        //   indentLevel: 2
        // })).join('');
        return this.encoder.encode(stripAnsiCode(msg) + eol);
    }
    /**
     * Log message with info level
     * @param args data to log
     */
    async info(...args) {
        args = [this.getInfo(), ...args];
        this.stdout(...args);
        if (this.dir) {
            await this.write({
                dir: this.dir,
                type: Types.INFO,
                args,
            });
        }
    }
    /**
     * Log message with warning level
     * @param args data to log
     */
    async warn(...args) {
        args = [this.getWarn(), ...args];
        this.stdout(...args);
        if (this.dir) {
            await this.write({
                dir: this.dir,
                type: Types.WARN,
                args,
            });
        }
    }
    /**
     * Log message with error level
     * @param args data to log
     */
    async error(...args) {
        args = [this.getError(), ...args];
        this.stdout(...args);
        if (this.dir) {
            await this.write({
                dir: this.dir,
                type: Types.ERROR,
                args,
            });
        }
    }
    write({ dir, type, args }) {
        const date = this.getDate();
        const filename = this.rotate === true ? `${date}_${type}` : type;
        const path = `${dir}/${filename}.log`;
        const msg = this.format(...args);
        return this.writer.write({ path, msg, type });
    }
    /**
     * init file logger
     * @param dir
     * @param options
     */
    async initFileLogger(dir, options = {}) {
        const exist = await exists(dir);
        if (!exist) {
            stdout(`${this.getWarn()} Log folder does not exist`);
            try {
                dntShim.Deno.mkdirSync(dir, { recursive: true });
                stdout(`${this.getInfo()} Log folder create success`);
            }
            catch (error) {
                stdout(`${this.getError()} Log folder create failed: ` + error);
            }
        }
        const { rotate, maxBytes, maxBackupCount } = options;
        if (rotate === true)
            this.rotate = true;
        this.dir = dir;
        this.writer = new Writer({
            maxBytes,
            maxBackupCount,
        });
    }
    /**
     * disable a specific type of logger
     * @param type Level of logger to disable
     */
    disable(type) {
        if (!type) {
            this.info = noop;
            this.warn = noop;
            this.error = noop;
            return;
        }
        if (type === "info") {
            this.info = noop;
            return;
        }
        if (type === "warn") {
            this.warn = noop;
            return;
        }
        if (type === "error") {
            this.error = noop;
            return;
        }
    }
    /**
     * Enable a specific type of logger
     * @param type Level of logger to enable
     */
    enable(type) {
        if (!type) {
            this.info = __classPrivateFieldGet(this, _Logger_info, "f");
            this.warn = __classPrivateFieldGet(this, _Logger_warn, "f");
            this.error = __classPrivateFieldGet(this, _Logger_error, "f");
        }
        if (type === "info") {
            this.info = __classPrivateFieldGet(this, _Logger_info, "f");
            return;
        }
        if (type === "warn") {
            this.warn = __classPrivateFieldGet(this, _Logger_warn, "f");
            return;
        }
        if (type === "error") {
            this.error = __classPrivateFieldGet(this, _Logger_error, "f");
            return;
        }
    }
    /**
     * Disable console logger
     */
    disableConsole() {
        this.stdout = noop;
    }
    /**
     * Enable console logger
     */
    enableConsole() {
        this.stdout = stdout;
    }
    /**
     * Disable file logger
     */
    disableFile() {
        this.write = noop;
    }
    /**
     * Enable file logger
     */
    enableFile() {
        this.write = __classPrivateFieldGet(this, _Logger_write, "f");
    }
    getInfo() {
        return green(`${this.getNow()} Info:`);
    }
    getWarn() {
        return green(this.getNow()) + yellow(` Warn:`);
    }
    getError() {
        return green(this.getNow()) + red(` Error:`);
    }
    getNow() {
        return new Dater().toLocaleString();
    }
    getDate() {
        return new Dater().toLocaleDateString();
    }
}
_Logger_info = new WeakMap(), _Logger_warn = new WeakMap(), _Logger_error = new WeakMap(), _Logger_write = new WeakMap();
export default Logger;
